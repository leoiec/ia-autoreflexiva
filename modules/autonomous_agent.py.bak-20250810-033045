# file: modules/autonomous_agent.py
"""
Single-file, import-friendly AutonomousAgent module.

Public API:
- __version__
- make_agent(...)
- run(request_json: str) -> str
- Classes: AutonomousAgent, Policy, MemoryAdapter, Decision, PatchProposal

Design goals:
- No heavy work at import time (no network/IO/telemetry here).
- Deterministic behavior to ease auditing.
- Memory logging is defensive and *privacy-aware* (redacts obvious secrets).
"""

from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import Any, Callable, Dict, List, Optional, Tuple
import json
import re
import time


__version__ = "0.2.1"  # bump when behavior changes


# ----------------------------- Data Models ---------------------------- #

@dataclass
class Decision:
    """Outcome of a plan evaluation."""
    action: str           # "proceed" | "revise" | "reject"
    confidence: float     # 0.0 - 1.0
    notes: str = ""       # short rationale


@dataclass
class PatchProposal:
    """
    A tiny, auditable patch suggestion. This agent NEVER writes files.
    Other system actors (Creator / Orchestrator) can consume this safely.
    """
    change: str                 # short id, e.g. "add_logging_guard"
    rationale: str              # why this helps
    target: str                 # function, class or file path hint
    patch_lines: List[str]      # human-readable snippet to apply
    meta: Dict[str, Any] = None # optional, for tooling hints

    def to_json(self) -> str:
        return json.dumps(
            {
                "change": self.change,
                "rationale": self.rationale,
                "target": self.target,
                "patch": self.patch_lines,
                "meta": self.meta or {},
            },
            indent=2,
        )


# ------------------------------ Policy -------------------------------- #

class Policy:
    """Very small guardrail layer for bounded execution."""
    def __init__(self, allow_network: bool = False, max_depth: int = 2):
        self.allow_network = allow_network
        self.max_depth = max_depth

    def validate(self, request: Dict[str, Any]) -> Tuple[bool, str]:
        depth = int(request.get("depth", 0) or 0)
        if depth > self.max_depth:
            return False, "depth_exceeded"
        wants_network = bool(request.get("network") or request.get("plan", {}).get("network"))
        if wants_network and not self.allow_network:
            return False, "network_forbidden"
        return True, "ok"


# ----------------------- Privacy-Aware Memory -------------------------- #

_SECRET_PATTERNS = [
    # API-style keys/tokens
    (re.compile(r"(?i)(api[_-]?key|token|secret|passwd|password)\s*[:=]\s*([^\s'\";]+)"), r"\1=<redacted>"),
    # Bearer tokens / Authorization headers
    (re.compile(r"(?i)(authorization)\s*:\s*bearer\s+[A-Za-z0-9\-\._~\+\/]+=*"), r"\1: Bearer <redacted>"),
    # sk- prefixed keys (e.g., OpenAI-style)
    (re.compile(r"\bsk-[A-Za-z0-9]{16,}\b"), "<redacted-key>"),
    # AWS Access Key ID
    (re.compile(r"\bAKIA[0-9A-Z]{16}\b"), "<redacted-aws-key>"),
    # Long hex/alnum sequences that look like secrets (heuristic: 24+ chars, mixed)
    (re.compile(r"\b[a-zA-Z0-9_\-]{24,}\b"), "<redacted>"),
    # Email addresses
    (re.compile(r"[\w\.-]+@[\w\.-]+\.\w+"), "<redacted-email>"),
    # Query params with tokens
    (re.compile(r"([?&](?:token|key|signature)=[^&#\s]+)", re.I), r"\1<redacted>"),
]

def _redact_secrets(text: str, max_len: int = 4000) -> str:
    if not text:
        return text
    out = text
    for pat, repl in _SECRET_PATTERNS:
        out = pat.sub(repl, out)
    if len(out) > max_len:
        out = out[:max_len] + " …[truncated]"
    return out


class MemoryAdapter:
    """
    Thin adapter. The outer system injects callables:
      - writer(event: dict) -> None
      - reader(query: dict) -> str
    Both are optional; this adapter is defensive and never raises.

    Privacy: `log()` redacts common secrets before writing.
    """
    def __init__(
        self,
        writer: Optional[Callable[[Dict[str, Any]], None]] = None,
        reader: Optional[Callable[[Dict[str, Any]], str]] = None,
    ):
        self._writer = writer
        self._reader = reader

    def log(self, title: str, note: str, tag: str = "agent", level: str = "info") -> None:
        safe_note = _redact_secrets(note or "")
        event = {
            "title": title,
            "note": safe_note,
            "tag": tag,
            "level": level,
            "ts": time.time(),
            "module": "autonomous_agent",
            "version": __version__,
        }
        if callable(self._writer):
            try:
                self._writer(event)
            except Exception:
                # Never crash because memory failed.
                pass

    def read_recent(self, limit: int = 20, tag: Optional[str] = None) -> List[str]:
        if callable(self._reader):
            try:
                payload = {"limit": int(limit)}
                if tag:
                    payload["tag"] = tag
                txt = self._reader(payload)
                if isinstance(txt, str):
                    return [ln for ln in txt.splitlines() if ln.strip()]
            except Exception:
                pass
        return []


# -------------------------- Agent Core Logic -------------------------- #

class AutonomousAgent:
    """
    Minimal, testable agent:
    - Validates a request against Policy
    - Deterministically scores a plan to decide proceed/revise
    - Proposes a tiny, deterministic PatchProposal when 'revise'
    - Emits memory logs via MemoryAdapter (if wired)
    """
    def __init__(self, policy: Policy, memory: Optional[MemoryAdapter] = None):
        self.policy = policy
        self.memory = memory or MemoryAdapter()

    # ---- Scoring ----
    def evaluate(self, plan: Dict[str, Any]) -> float:
        """
        Deterministic score in [0,1]:
        - penalize network use (-0.30)
        - penalize high risk (-0.40), medium (-0.15)
        - small bonus per step (+0.05 up to +0.30)
        - small bonus if plan lists explicit tests (+0.10)
        """
        score = 1.0

        if plan.get("network"):
            score -= 0.30

        risk = (plan.get("risk") or "").lower()
        if risk == "high":
            score -= 0.40
        elif risk == "medium":
            score -= 0.15

        steps = plan.get("steps") or []
        score += min(0.30, 0.05 * len(steps))

        if plan.get("tests"):
            score += 0.10

        # clamp
        if score < 0.0:
            score = 0.0
        if score > 1.0:
            score = 1.0
        return score

    # ---- Decisioning ----
    def decide(self, request: Dict[str, Any]) -> Decision:
        ok, why = self.policy.validate(request)
        if not ok:
            self.memory.log("policy_block", f"blocked: {why}", "policy", "rejected")
            return Decision(action="reject", confidence=0.90, notes=why)

        confidence = self.evaluate(request.get("plan", {}))
        action = "proceed" if confidence >= 0.60 else "revise"
        # Defensive log: ensure memory adapter presence does not crash decisioning.
        try:
            self.memory.log(
                "decision",
                f"{action}@{confidence:.2f} (risk={request.get('plan',{}).get('risk','n/a')})",
                "agent",
                "success",
            )
        except Exception:
            # Swallow logging errors to keep decision flow stable.
            pass
        return Decision(action=action, confidence=confidence, notes="auto-evaluated")

    # ---- Patch Proposals ----
    def propose_patch(self, current_code: str) -> PatchProposal:
        """
        Return a tiny, deterministic patch suggestion so other agents can audit easily.
        This does NOT modify files—only proposes changes.
        """
        lines = [
            "# Guard: avoid AttributeError if memory adapter lacks 'log' or is None",
            "if not hasattr(self.memory, 'log') or not callable(getattr(self.memory, 'log', None)):",
            "    return Decision(action='revise', confidence=0.50, notes='no-memory-logger')",
        ]
        return PatchProposal(
            change="add_logging_guard",
            rationale="Ensure decision flow is resilient even if memory logger is unavailable.",
            target="AutonomousAgent.decide",
            patch_lines=lines,
            meta={"module": "autonomous_agent", "version": __version__},
        )

    # ---- Orchestrator-friendly runner ----
    def run_once(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Single pass: decide + optional patch."""
        decision = self.decide(request)
        out: Dict[str, Any] = {"version": __version__, "decision": asdict(decision)}
        if decision.action == "revise":
            out["patch"] = json.loads(self.propose_patch(request.get("current_code", "")).to_json())
        return out


# ------------------------------ Entrypoints --------------------------- #

def make_agent(policy: Optional[Policy] = None, memory: Optional[MemoryAdapter] = None) -> AutonomousAgent:
    """Factory to construct an AutonomousAgent with safe defaults."""
    policy = policy if policy is not None else Policy()
    memory = memory if memory is not None else MemoryAdapter()
    return AutonomousAgent(policy=policy, memory=memory)


def run(request_json: str) -> str:
    """
    JSON API for external callers.

    Expected keys (optional unless noted):
      - allow_network: bool
      - max_depth: int
      - depth: int
      - network: bool
      - plan: {
          steps: [..],
          risk: "low"|"medium"|"high",
          network: bool,
          tests: [..]
        }
      - current_code: str

    Note: Memory hooks are not wired here; the outer system can instantiate
    AutonomousAgent(policy, MemoryAdapter(writer, reader)) for full functionality.
    """
    req = json.loads(request_json or "{}")
    pol = Policy(
        allow_network=bool(req.get("allow_network", False)),
        max_depth=int(req.get("max_depth", 2)),
    )
    agent = AutonomousAgent(pol, memory=MemoryAdapter())  # no-op memory by default
    result = agent.run_once(req)
    return json.dumps(result, indent=2)
